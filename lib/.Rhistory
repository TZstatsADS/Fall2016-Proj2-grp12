plot(1:15, wss, type="b", main = "Types of Drivers: Cluster Analysis - Determining Number of clusters", xlab="Number of Clusters",
ylab="Within groups sum of squares")
# K-Means Cluster Analysis
fit <- kmeans(transactions.driver.factors[,-1], centers = 2, nstart = 500) # 2 cluster solution
# get cluster means
aggregate(transactions.driver.factors[,-1],by=list(fit$cluster),FUN=mean)
# append cluster assignment
transactions.driver.factors.cluster <- data.frame(transactions.driver.factors, fit$cluster)
#clusplot(transactions.driver.factors, fit$cluster, color=TRUE, shade=TRUE,
#  	labels=2, lines=0)
# Centroid Plot against 1st 2 discriminant functions
#plotcluster(transactions.driver.factors[,-1], fit$cluster)
# PCA Plot
transactions.driver.pca <- prcomp(transactions.driver.factors[,-1], center = TRUE, scale. = TRUE)
g <- ggbiplot(transactions.driver.pca, obs.scale = 1, var.scale = 1,
groups = as.factor(transactions.driver.factors.cluster$fit.cluster), ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
g
driver.value <- group_by(transactions.driver, driver.id) %>%
dplyr::summarise(TotalDollars = sum(TotalDollars))
driver.value$LTVD <- driver.value$TotalDollars / as.integer(timeframe)
driver.value$LTV <- driver.value$LTVD * 3650
transactions.driver.factors.cluster.value <- inner_join(transactions.driver.factors.cluster,
driver.value,
by = "driver.id")
plot_ly(data = transactions.driver.factors.cluster.value,
y = LTV,
x = fit.cluster,
type = "box") %>%
layout(autosize = FALSE, width = 800,
title = "Driver Lifetime Value per cluster",
xaxis = list(title = "Cluster"),
yaxis = list(title = "Lifetime Value (LTV)"))
lm.weekday <- lm(LTV ~ Monday + Tuesday + Wednesday + Thursday + Friday + Saturday + Sunday ,
data = transactions.driver.factors.cluster.value)
#plot_ly(x = lm.weekday$coefficients[1], y = lm.weekday$coefficients[2], type = "bar")
summary(lm.weekday)
lm.weekday$coefficients
plot(lm.weekday$coefficients[-1],
main = "Impact of Workday in Driver Lifetime Value",
xlab = "Day of the Week",
ylab = "Impact of Workday in LTV",
pch = 18)
rm(list = ls(all=TRUE))
## Load the libraries
library(readr)
library(plotly)
library(ggplot2)
library(lubridate)
library(tidyr)
library(cluster)
library(fpc)
library(devtools)
library(ggbiplot)
library(dplyr)
# Extract data
transaction.data <- read_csv("./data/lyft_data.csv")
## Transform Data
# Sorty by Unix Date
transaction.data <- transaction.data[order(transaction.data$unix.timestamp),]
transaction.data$driver.id <- factor(transaction.data$driver.id)
# Convert timestamp to date field
transaction.data$unix.timestamp.date <- as.POSIXct(transaction.data$unix.timestamp, origin="1970-01-01")
# Capture Weekday
transaction.data$day <- as.character(trunc(transaction.data$unix.timestamp.date, units = "days"))
transaction.data$hour <- hour(round_date(transaction.data$unix.timestamp.date, "hour"))
transaction.data$DayOfWeek <- weekdays(as.Date(transaction.data$unix.timestamp.date))
transaction.data$DayOfWeek <- factor(transaction.data$DayOfWeek, levels = c("Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday",
"Sunday"))
transaction.data$weekend <- 0
transaction.data$weekend[transaction.data$DayOfWeek %in% c("Saturday", "Sunday")] <- 1
#transaction.data$TimeOfDay[transaction.data$hour <= ]
unique(transaction.data$hour)
total.rows <- nrow(transaction.data)
initial.date <- min(transaction.data$unix.timestamp.date)
final.date <- max(transaction.data$unix.timestamp.date)
timeframe <- difftime(final.date, initial.date, units = "days")
num.drivers <- unique(transaction.data$driver.id)
total.bill <- sum(transaction.data$total.bill.usd)
daily.value <- total.bill / as.double(timeframe) / length(num.drivers)
#daily.transactions <- group_by(transaction.data, DayOfWeek ) %>%
#  summarise(count = n(),
#            TotalDollars = sum(total.bill.usd) )
plot_ly(x = transaction.data$day , type = "histogram") %>%
layout(autosize = FALSE, width = 800, title = "Daily number of transactions")
subplot(
plot_ly(y = transaction.data$total.bill.usd , type = "box") %>%
layout(autosize = FALSE, width = 800),
plot_ly(x = transaction.data$total.bill.usd , type = "histogram") %>%
layout(autosize = FALSE, width = 800),
margin = 0.05
) %>%
layout(title = paste("Distribution of Bills (in USD), #bills:",
format(total.rows, big.mark = ","),
"SUM(USD):", format(total.bill, big.mark = ",") ),
yaxis = list(title = "Bills (in USD)"),
showlegend = FALSE
)
#daily.transactions <- group_by(transaction.data, DayOfWeek ) %>%
#  summarise(count = n(),
#            TotalDollars = sum(total.bill.usd) )
subplot(
plot_ly(x = transaction.data$DayOfWeek, type = "histogram") %>%
layout(autosize = FALSE, width = 800,
xaxis = list(type = "category",
categoryorder = "array",
categoryarray = c("Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday",
"Sunday")
)
),
plot_ly(y = transaction.data$total.bill.usd, color = transaction.data$DayOfWeek, type = "box") %>%
layout(autosize = FALSE, width = 800,
xaxis = list(autorange = "reversed"),
showlegend = FALSE)
) %>%
layout(title = "Breakdown of Transactions into Day of the Week | Count and dollar amount")
transaction.data$thursSun <- '0'
transaction.data$thursSun[transaction.data$DayOfWeek %in% c("Thursday",
"Friday",
"Saturday",
"Sunday")] <- '1'
transactions.driver <- group_by(transaction.data, driver.id, day, DayOfWeek, thursSun) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(total.bill.usd) )
sp <- ggplot(data = transactions.driver, aes(x =day, y=count, fill=thursSun)) +
geom_bar(stat = "sum") +
facet_grid(driver.id ~ .) +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
sp
# Transactions per driver per day of weeek #1
transactions.driver.dayofweek <- group_by(transactions.driver, driver.id, DayOfWeek) %>%
dplyr::summarise(count = sum(count),
TotalDollars = sum(TotalDollars) )
# Calculating number of days for each day of week #2
transactions.daysofweek.base <- group_by(transaction.data, day, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(total.bill.usd) )
transactions.daysofweek <- group_by(transactions.daysofweek.base, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(TotalDollars) )
# Join #1 and #2
transactions.driver.dayofweek <- dplyr::inner_join(transactions.driver.dayofweek, transactions.daysofweek,
by = c("DayOfWeek"),
suffix = c(".driver", ".DayOfWeek"))
# Calculate transactions per day, for each DayOfWeek
transactions.driver.dayofweek$CountPerDay <- transactions.driver.dayofweek$count.driver / transactions.driver.dayofweek$count.DayOfWeek
# Spread DayofWeek data over columns, as factors
transactions.driver.factors <- spread(transactions.driver.dayofweek[,c("driver.id", "DayOfWeek","CountPerDay")],
DayOfWeek,
CountPerDay,
fill = 0)
## Cluster Analysis
# Determine number of clusters
wss <- (nrow(transactions.driver.factors)-1)*sum(apply(transactions.driver.factors,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(transactions.driver.factors[,-1],
centers=i, nstart = 500 )$withinss)
plot(1:15, wss, type="b", main = "Types of Drivers: Cluster Analysis - Determining Number of clusters", xlab="Number of Clusters",
ylab="Within groups sum of squares")
# K-Means Cluster Analysis
fit <- kmeans(transactions.driver.factors[,-1], centers = 2, nstart = 500) # 2 cluster solution
# get cluster means
aggregate(transactions.driver.factors[,-1],by=list(fit$cluster),FUN=mean)
# append cluster assignment
transactions.driver.factors.cluster <- data.frame(transactions.driver.factors, fit$cluster)
#clusplot(transactions.driver.factors, fit$cluster, color=TRUE, shade=TRUE,
#  	labels=2, lines=0)
# Centroid Plot against 1st 2 discriminant functions
#plotcluster(transactions.driver.factors[,-1], fit$cluster)
# PCA Plot
transactions.driver.pca <- prcomp(transactions.driver.factors[,-1], center = TRUE, scale. = TRUE)
g <- ggbiplot(transactions.driver.pca, obs.scale = 1, var.scale = 1,
groups = as.factor(transactions.driver.factors.cluster$fit.cluster), ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
g
driver.value <- group_by(transactions.driver, driver.id) %>%
dplyr::summarise(TotalDollars = sum(TotalDollars))
driver.value$LTVD <- driver.value$TotalDollars / as.integer(timeframe)
driver.value$LTV <- driver.value$LTVD * 3650
transactions.driver.factors.cluster.value <- inner_join(transactions.driver.factors.cluster,
driver.value,
by = "driver.id")
plot_ly(data = transactions.driver.factors.cluster.value,
y = LTV,
x = fit.cluster,
type = "box") %>%
layout(autosize = FALSE, width = 800,
title = "Driver Lifetime Value per cluster",
xaxis = list(title = "Cluster"),
yaxis = list(title = "Lifetime Value (LTV)"))
lm.weekday <- lm(LTV ~ Monday + Tuesday + Wednesday + Thursday + Friday + Saturday + Sunday ,
data = transactions.driver.factors.cluster.value)
#plot_ly(x = lm.weekday$coefficients[1], y = lm.weekday$coefficients[2], type = "bar")
summary(lm.weekday)
lm.weekday$coefficients
plot(lm.weekday$coefficients[-1],
main = "Impact of Workday in Driver Lifetime Value",
xlab = "Day of the Week",
ylab = "Impact of Workday in LTV",
pch = 18)
# Transactions per driver per day of weeek #1
transactions.driver.dayofweek <- group_by(transactions.driver, driver.id, DayOfWeek) %>%
dplyr::summarise(count = sum(count),
TotalDollars = sum(TotalDollars) )
# Calculating number of days for each day of week #2
transactions.daysofweek.base <- group_by(transaction.data, day, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(total.bill.usd) )
transactions.daysofweek <- group_by(transactions.daysofweek.base, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(TotalDollars) )
# Join #1 and #2
transactions.driver.dayofweek <- dplyr::inner_join(transactions.driver.dayofweek, transactions.daysofweek,
by = c("DayOfWeek"),
suffix = c(".driver", ".DayOfWeek"))
# Calculate transactions per day, for each DayOfWeek
transactions.driver.dayofweek$CountPerDay <- transactions.driver.dayofweek$count.driver / transactions.driver.dayofweek$count.DayOfWeek
# Spread DayofWeek data over columns, as factors
transactions.driver.factors <- spread(transactions.driver.dayofweek[,c("driver.id", "DayOfWeek","CountPerDay")],
DayOfWeek,
CountPerDay,
fill = 0)
## Cluster Analysis
# Determine number of clusters
wss <- (nrow(transactions.driver.factors)-1)*sum(apply(transactions.driver.factors,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(transactions.driver.factors[,-1],
centers=i, nstart = 500 )$withinss)
plot(1:15, wss, type="b", main = "Types of Drivers: Cluster Analysis - Determining Number of clusters", xlab="Number of Clusters",
ylab="Within groups sum of squares")
rm(list = ls(all=TRUE))
## Load the libraries
library(readr)
library(plotly)
library(ggplot2)
library(lubridate)
library(tidyr)
library(cluster)
library(fpc)
library(devtools)
library(ggbiplot)
library(dplyr)
# Extract data
transaction.data <- read_csv("./data/lyft_data.csv")
## Transform Data
# Sorty by Unix Date
transaction.data <- transaction.data[order(transaction.data$unix.timestamp),]
transaction.data$driver.id <- factor(transaction.data$driver.id)
# Convert timestamp to date field
transaction.data$unix.timestamp.date <- as.POSIXct(transaction.data$unix.timestamp, origin="1970-01-01")
# Capture Weekday
transaction.data$day <- as.character(trunc(transaction.data$unix.timestamp.date, units = "days"))
transaction.data$hour <- hour(round_date(transaction.data$unix.timestamp.date, "hour"))
transaction.data$DayOfWeek <- weekdays(as.Date(transaction.data$unix.timestamp.date))
transaction.data$DayOfWeek <- factor(transaction.data$DayOfWeek, levels = c("Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday",
"Sunday"))
transaction.data$weekend <- 0
transaction.data$weekend[transaction.data$DayOfWeek %in% c("Saturday", "Sunday")] <- 1
#transaction.data$TimeOfDay[transaction.data$hour <= ]
unique(transaction.data$hour)
total.rows <- nrow(transaction.data)
initial.date <- min(transaction.data$unix.timestamp.date)
final.date <- max(transaction.data$unix.timestamp.date)
timeframe <- difftime(final.date, initial.date, units = "days")
num.drivers <- unique(transaction.data$driver.id)
total.bill <- sum(transaction.data$total.bill.usd)
daily.value <- total.bill / as.double(timeframe) / length(num.drivers)
#daily.transactions <- group_by(transaction.data, DayOfWeek ) %>%
#  summarise(count = n(),
#            TotalDollars = sum(total.bill.usd) )
plot_ly(x = transaction.data$day , type = "histogram") %>%
layout(autosize = FALSE, width = 800, title = "Daily number of transactions")
subplot(
plot_ly(y = transaction.data$total.bill.usd , type = "box") %>%
layout(autosize = FALSE, width = 800),
plot_ly(x = transaction.data$total.bill.usd , type = "histogram") %>%
layout(autosize = FALSE, width = 800),
margin = 0.05
) %>%
layout(title = paste("Distribution of Bills (in USD), #bills:",
format(total.rows, big.mark = ","),
"SUM(USD):", format(total.bill, big.mark = ",") ),
yaxis = list(title = "Bills (in USD)"),
showlegend = FALSE
)
#daily.transactions <- group_by(transaction.data, DayOfWeek ) %>%
#  summarise(count = n(),
#            TotalDollars = sum(total.bill.usd) )
subplot(
plot_ly(x = transaction.data$DayOfWeek, type = "histogram") %>%
layout(autosize = FALSE, width = 800,
xaxis = list(type = "category",
categoryorder = "array",
categoryarray = c("Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday",
"Sunday")
)
),
plot_ly(y = transaction.data$total.bill.usd, color = transaction.data$DayOfWeek, type = "box") %>%
layout(autosize = FALSE, width = 800,
xaxis = list(autorange = "reversed"),
showlegend = FALSE)
) %>%
layout(title = "Breakdown of Transactions into Day of the Week | Count and dollar amount")
transaction.data$thursSun <- '0'
transaction.data$thursSun[transaction.data$DayOfWeek %in% c("Thursday",
"Friday",
"Saturday",
"Sunday")] <- '1'
transactions.driver <- group_by(transaction.data, driver.id, day, DayOfWeek, thursSun) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(total.bill.usd) )
sp <- ggplot(data = transactions.driver, aes(x =day, y=count, fill=thursSun)) +
geom_bar(stat = "sum") +
facet_grid(driver.id ~ .) +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
sp
# Transactions per driver per day of weeek #1
transactions.driver.dayofweek <- group_by(transactions.driver, driver.id, DayOfWeek) %>%
dplyr::summarise(count = sum(count),
TotalDollars = sum(TotalDollars) )
# Calculating number of days for each day of week #2
transactions.daysofweek.base <- group_by(transaction.data, day, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(total.bill.usd) )
transactions.daysofweek <- group_by(transactions.daysofweek.base, DayOfWeek) %>%
dplyr::summarise(count = n(),
TotalDollars = sum(TotalDollars) )
# Join #1 and #2
transactions.driver.dayofweek <- dplyr::inner_join(transactions.driver.dayofweek, transactions.daysofweek,
by = c("DayOfWeek"),
suffix = c(".driver", ".DayOfWeek"))
# Calculate transactions per day, for each DayOfWeek
transactions.driver.dayofweek$CountPerDay <- transactions.driver.dayofweek$count.driver / transactions.driver.dayofweek$count.DayOfWeek
# Spread DayofWeek data over columns, as factors
transactions.driver.factors <- spread(transactions.driver.dayofweek[,c("driver.id", "DayOfWeek","CountPerDay")],
DayOfWeek,
CountPerDay,
fill = 0)
## Cluster Analysis
# Determine number of clusters
wss <- (nrow(transactions.driver.factors)-1)*sum(apply(transactions.driver.factors,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(transactions.driver.factors[,-1],
centers=i, nstart = 500 )$withinss)
plot(1:15, wss, type="b", main = "Types of Drivers: Cluster Analysis - Determining Number of clusters", xlab="Number of Clusters",
ylab="Within groups sum of squares")
# K-Means Cluster Analysis
fit <- kmeans(transactions.driver.factors[,-1], centers = 2, nstart = 500) # 2 cluster solution
# get cluster means
aggregate(transactions.driver.factors[,-1],by=list(fit$cluster),FUN=mean)
# append cluster assignment
transactions.driver.factors.cluster <- data.frame(transactions.driver.factors, fit$cluster)
#clusplot(transactions.driver.factors, fit$cluster, color=TRUE, shade=TRUE,
#  	labels=2, lines=0)
# Centroid Plot against 1st 2 discriminant functions
#plotcluster(transactions.driver.factors[,-1], fit$cluster)
# PCA Plot
transactions.driver.pca <- prcomp(transactions.driver.factors[,-1], center = TRUE, scale. = TRUE)
g <- ggbiplot(transactions.driver.pca, obs.scale = 1, var.scale = 1,
groups = as.factor(transactions.driver.factors.cluster$fit.cluster), ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
g
driver.value <- group_by(transactions.driver, driver.id) %>%
dplyr::summarise(TotalDollars = sum(TotalDollars))
driver.value$LTVD <- driver.value$TotalDollars / as.integer(timeframe)
driver.value$LTV <- driver.value$LTVD * 3650
transactions.driver.factors.cluster.value <- inner_join(transactions.driver.factors.cluster,
driver.value,
by = "driver.id")
plot_ly(data = transactions.driver.factors.cluster.value,
y = LTV,
x = fit.cluster,
type = "box") %>%
layout(autosize = FALSE, width = 800,
title = "Driver Lifetime Value per cluster",
xaxis = list(title = "Cluster"),
yaxis = list(title = "Lifetime Value (LTV)"))
lm.weekday <- lm(LTV ~ Monday + Tuesday + Wednesday + Thursday + Friday + Saturday + Sunday ,
data = transactions.driver.factors.cluster.value)
#plot_ly(x = lm.weekday$coefficients[1], y = lm.weekday$coefficients[2], type = "bar")
summary(lm.weekday)
lm.weekday$coefficients
plot(lm.weekday$coefficients[-1],
main = "Impact of Workday in Driver Lifetime Value",
xlab = "Day of the Week",
ylab = "Impact of Workday in LTV",
pch = 18)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Shiny_Server/run.R', echo=TRUE)
runApp(getwd())
shiny::runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Shiny_Server')
runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Shiny_Server')
restaurant_uniques_1<-na.omit(restaurant_uniques_1)
shiny::runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Project02/Fall2016-Proj2-grp12/app/NYC_Coffee_Stop')
install.packages("RJSONIO")
shiny::runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Project02/Fall2016-Proj2-grp12/app/NYC_Coffee_Stop')
shiny::runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Project02/Spr2016-Proj2-Grp1/app')
shiny::runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Project02/Fall2016-Proj2-grp12/app')
restaurant.data <- read.csv("../output/restaurants_unique_geocoded.csv")
wifi.data <- read.csv("../data/NYC_Wi-Fi_Hotspot_Locations_Map.csv")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
restaurant.data <- read.csv("../output/restaurants_unique_geocoded.csv")
wifi.data <- read.csv("../data/NYC_Wi-Fi_Hotspot_Locations_Map.csv")
wifi.geodata <- create.wifi.geodata(wifi.data)
CL <- create.wifi.contour.lines(wifi.geodata)
runApp()
library(dplyr)
library(ggmap)
library(ggplot2)
library(DT)
library(readr)
library(data.table)
library(qmap)
library(maps)
library(leaflet)
library(raster)
library(sp)
library(rgdal)
library(maptools)
library(KernSmooth)
# Function to set wd
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#setwd("/Users/zuonianyao/Documents/GR5243/Project2")
wifi <- fread("../data/NYC_Wi-Fi_Hotspot_Locations_Map.csv")
create.wifi.geodata <- function(wifi.data){
wifi_1 <- wifi.data %>%
dplyr::select(Type,Location,Lat,Long_,Location_T,City) %>%
filter(Type=="Free"|Type=="Limited Free")
wifi.geodata <- na.omit(wifi_1)
return(wifi.geodata)
}
create.wifi.contour.lines <- function(wifi.geodata){
X=cbind(wifi.geodata$Long_,wifi.geodata$Lat)
kde2d <- bkde2D(X, bandwidth=c(bw.ucv(X[,1]),bw.ucv(X[,2])))
x <- kde2d$x1
y <- kde2d$x2
z <- kde2d$fhat
CL=contourLines(x , y , z)
return(CL)
}
add.wifi.points <- function(leaflet.plot){
leaflet.plot <- leaflet.plot %>%
addCircles(wifi.geodata$Long_,wifi.geodata$Lat, radius = 0.1,opacity=0.4,col="orange")
return(leaflet.plot)
}
add.wifi.contours <- function(leaflet.plot, CL){
leaflet.plot <- leaflet.plot %>%
addPolygons(CL[[1]]$x,CL[[1]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[2]]$x,CL[[2]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[3]]$x,CL[[3]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[4]]$x,CL[[4]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[5]]$x,CL[[5]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[6]]$x,CL[[6]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[7]]$x,CL[[7]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[8]]$x,CL[[8]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[9]]$x,CL[[9]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[10]]$x,CL[[10]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[11]]$x,CL[[11]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[12]]$x,CL[[12]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[13]]$x,CL[[13]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[14]]$x,CL[[14]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[15]]$x,CL[[15]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[16]]$x,CL[[16]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[17]]$x,CL[[17]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[18]]$x,CL[[18]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[19]]$x,CL[[19]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[20]]$x,CL[[20]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[21]]$x,CL[[21]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[22]]$x,CL[[22]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[23]]$x,CL[[23]]$y,fillColor = "red", stroke = FALSE) %>%
addPolygons(CL[[24]]$x,CL[[24]]$y,fillColor = "red", stroke = FALSE)
return(leaflet.plot)
}
## Run to test functions
wifi.geodata <- create.wifi.geodata(wifi)
CL <- create.wifi.contour.lines(wifi.geodata)
m = leaflet() %>% setView(lng = -73.97, lat = 40.75, zoom = 12) %>%
addProviderTiles("CartoDB.Positron")
m <- add.wifi.points(m)
m <- add.wifi.contours(m, CL)
m
runApp('C:/Users/jgaci/Dropbox/2016_Fall/Applied_Data_Science/Project02/Fall2016-Proj2-grp12/app')
